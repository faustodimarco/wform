/**
 * SimpleFormly - Combined minified version
 * A self-hostable multi-step form solution for Webflow
 * 
 * This file combines all the necessary components into a single minified file
 * for easy inclusion in Webflow projects.
 */

/**
 * EventEmitter - Custom event system for SimpleFormly
 */
class EventEmitter {
  constructor() {
    this.events = {};
  }
  
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }
  
  off(event, callback) {
    if (!this.events[event]) return;
    this.events[event] = this.events[event].filter(cb => cb !== callback);
  }
  
  emit(event, data) {
    if (!this.events[event]) return;
    this.events[event].forEach(callback => {
      try {
        callback(data);
      } catch (error) {
        console.error(`Error in event listener for ${event}:`, error);
      }
    });
  }
}

/**
 * ErrorHandler - Error handling utility for SimpleFormly
 */
class ErrorHandler {
  static log(message, type = 'log') {
    console[type](`[SimpleFormly] ${message}`);
  }
  
  static warn(message) {
    this.log(message, 'warn');
  }
  
  static error(message) {
    this.log(message, 'error');
  }
  
  static showInputError(input, message) {
    try {
      input.classList.add('error');
      const wrapper = input.closest('.form-input-wrapper');
      if (wrapper) {
        wrapper.classList.add('error');
      }
      
      const errorElement = input.parentElement.querySelector('.error-message');
      if (errorElement) {
        errorElement.textContent = message || input.validationMessage || 'Invalid input';
        errorElement.style.display = '';
      } else {
        const newErrorElement = document.createElement('div');
        newErrorElement.className = 'error-message';
        newErrorElement.textContent = message || input.validationMessage || 'Invalid input';
        newErrorElement.style.color = 'red';
        newErrorElement.style.fontSize = '12px';
        newErrorElement.style.marginTop = '4px';
        
        const target = wrapper || input;
        target.parentNode.insertBefore(newErrorElement, target.nextSibling);
      }
      
      this.log(`Validation error: ${message || input.validationMessage || 'Invalid input'}`, 'error');
    } catch (error) {
      this.error(`Error showing input error: ${error.message}`);
      console.error(error);
    }
  }
  
  static clearInputError(input) {
    try {
      input.classList.remove('error');
      const wrapper = input.closest('.form-input-wrapper');
      if (wrapper) {
        wrapper.classList.remove('error');
      }
      
      const errorElement = input.parentElement.querySelector('.error-message');
      if (errorElement) {
        errorElement.textContent = '';
        errorElement.style.display = 'none';
      }
    } catch (error) {
      this.error(`Error clearing input error: ${error.message}`);
      console.error(error);
    }
  }
}

/**
 * DOMUtils - DOM utility functions for SimpleFormly
 */
class DOMUtils {
  static findByData(attribute, value, context = document) {
    return Array.from(context.querySelectorAll(`[data-${attribute}="${value}"]`));
  }
  
  static show(element) {
    if (!element) return;
    element.style.display = '';
  }
  
  static hide(element) {
    if (!element) return;
    element.style.display = 'none';
  }
  
  static addClass(element, className) {
    if (!element) return;
    element.classList.add(className);
  }
  
  static removeClass(element, className) {
    if (!element) return;
    element.classList.remove(className);
  }
  
  static toggleClass(element, className, force) {
    if (!element) return;
    element.classList.toggle(className, force);
  }
  
  static hasClass(element, className) {
    if (!element) return false;
    return element.classList.contains(className);
  }
  
  static scrollTo(element, options = {}) {
    if (!element) return;
    const defaultOptions = {
      behavior: 'smooth',
      block: 'start'
    };
    const scrollOptions = { ...defaultOptions, ...options };
    element.scrollIntoView(scrollOptions);
  }
}

/**
 * ValidationRules - Validation rules for SimpleFormly
 */
class ValidationRules {
  static validateEmail(value) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(value);
  }
  
  static validatePhone(value) {
    const digitsOnly = value.replace(/\D/g, '');
    return digitsOnly.length >= 7;
  }
  
  static validateRequired(value) {
    return value.trim().length > 0;
  }
  
  static validateNumber(value, options = {}) {
    const num = parseFloat(value);
    if (isNaN(num)) {
      return false;
    }
    if (options.min !== undefined && num < options.min) {
      return false;
    }
    if (options.max !== undefined && num > options.max) {
      return false;
    }
    return true;
  }
  
  static validateCheckbox(checked, required) {
    return !required || checked;
  }
  
  static validateRadioGroup(radioGroup, required) {
    if (!required) {
      return true;
    }
    return Array.from(radioGroup).some(radio => radio.checked);
  }
  
  static validateSelect(value, required) {
    if (!required) {
      return true;
    }
    return value !== '';
  }
  
  static formatPhone(value, format) {
    const digitsOnly = value.replace(/\D/g, '');
    if (!format || !digitsOnly) {
      return digitsOnly;
    }
    
    let result = '';
    let digitIndex = 0;
    
    for (let i = 0; i < format.length; i++) {
      if (format[i] === 'x') {
        if (digitIndex < digitsOnly.length) {
          result += digitsOnly[digitIndex];
          digitIndex++;
        } else {
          break;
        }
      } else {
        result += format[i];
      }
    }
    
    return result;
  }
}

/**
 * Step - Step management for SimpleFormly
 */
class Step {
  constructor(element, index, eventEmitter) {
    this.element = element;
    this.index = index;
    this.eventEmitter = eventEmitter;
    this.inputs = [];
    this.isValid = false;
    this.isCard = element.getAttribute('data-card') === 'true';
    this.initialized = false;
  }
  
  init() {
    try {
      if (this.initialized) {
        ErrorHandler.warn(`Step ${this.index + 1} already initialized`);
        return;
      }
      
      this.findInputs();
      this.setupEventListeners();
      
      this.hide();
      
      this.initialized = true;
      this.eventEmitter.emit('step:init', { step: this });
      
      ErrorHandler.log(`Step ${this.index + 1} initialized successfully`, 'info');
    } catch (error) {
      ErrorHandler.error(`Error initializing step ${this.index + 1}: ${error.message}`);
      console.error(error);
    }
  }
  
  findInputs() {
    try {
      const inputElements = this.element.querySelectorAll('input, select, textarea');
      
      inputElements.forEach(inputElement => {
        this.inputs.push(inputElement);
      });
      
      if (this.isCard || this.inputs.length === 0) {
        this.isValid = true;
      } else {
        this.isValid = false;
      }
      
      ErrorHandler.log(`Found ${this.inputs.length} inputs in step ${this.index + 1}`, 'info');
    } catch (error) {
      ErrorHandler.error(`Error finding inputs in step ${this.index + 1}: ${error.message}`);
      console.error(error);
    }
  }
  
  setupEventListeners() {
    try {
      this.inputs.forEach(input => {
        input.addEventListener('input', () => {
          this.eventEmitter.emit('input:change', { 
            step: this, 
            input: input 
          });
        });
        
        input.addEventListener('blur', () => {
          this.eventEmitter.emit('input:blur', { 
            step: this, 
            input: input 
          });
        });
      });
      
      ErrorHandler.log(`Event listeners setup for step ${this.index + 1}`, 'info');
    } catch (error) {
      ErrorHandler.error(`Error setting up event listeners for step ${this.index + 1}: ${error.message}`);
      console.error(error);
    }
  }
  
  show() {
    try {
      DOMUtils.show(this.element);
      this.eventEmitter.emit('step:show', { step: this });
      
      ErrorHandler.log(`Step ${this.index + 1} shown`, 'info');
    } catch (error) {
      ErrorHandler.error(`Error showing step ${this.index + 1}: ${error.message}`);
      console.error(error);
    }
  }
  
  hide() {
    try {
      DOMUtils.hide(this.element);
      this.eventEmitter.emit('step:hide', { step: this });
      
      ErrorHandler.log(`Step ${this.index + 1} hidden`, 'info');
    } catch (error) {
      ErrorHandler.error(`Error hiding step ${this.index + 1}: ${error.message}`);
      console.error(error);
    }
  }
  
  hasRequiredFields() {
    return this.inputs.some(input => input.required);
  }
  
  getRequiredInputs() {
    return this.inputs.filter(input => input.required);
  }
  
  setValidity(isValid) {
    this.isValid = isValid;
    this.eventEmitter.emit('step:validate', { 
      step: this, 
      isValid: isValid 
    });
    
    ErrorHandler.log(`Step ${this.index + 1} validity set to ${isValid}`, 'info');
  }
}

/**
 * Validator - Validation engine for SimpleFormly
 */
class Validator {
  constructor(form, eventEmitter) {
    this.form = form;
    this.eventEmitter = eventEmitter;
    this.initialized = false;
  }
  
  init() {
    try {
      if (this.initialized) {
        ErrorHandler.warn('Validator already initialized');
        return;
      }
      
      this.setupEventListeners();
      
      this.initialized = true;
      this.eventEmitter.emit('validator:init', { validator: this });
      
      ErrorHandler.log('Validator initialized successfully', 'info');
    } catch (error) {
      ErrorHandler.error(`Error initializing validator: ${error.message}`);
      console.error(error);
    }
  }
  
  setupEventListeners() {
    try {
      this.eventEmitter.on('input:change', (data) => {
        this.validateInput(data.input);
        this.updateStepValidity(data.step);
        this.updateButtonState();
      });
      
      this.eventEmitter.on('input:blur', (data) => {
        this.validateInput(data.input);
        this.updateStepValidity(data.step);
        this.updateButtonState();
      });
      
      this.eventEmitter.on('step:change', () => {
        this.updateButtonState();
      });
      
      ErrorHandler.log('Validator event listeners setup successfully', 'info');
    } catch (error) {
      ErrorHandler.error(`Error setting up validator event listeners: ${error.message}`);
      console.error(error);
    }
  }
  
  validateStep(step) {
    try {
      if (step.isCard || step.inputs.length === 0) {
        step.setValidity(true);
        return true;
      }
      
      let isValid = true;
      
      step.inputs.forEach(input => {
        if (!this.validateInput(input)) {
          isValid = false;
        }
      });
      
      step.setValidity(isValid);
      
      this.updateButtonState();
      
      return isValid;
    } catch (error) {
      ErrorHandler.error(`Error validating step ${step.index + 1}: ${error.message}`);
      console.error(error);
      return false;
    }
  }
  
  validateInput(input) {
    try {
      if (input.disabled || input.type === 'hidden') {
        return true;
      }
      
      const isRequired = input.required;
      
      if (!isRequired && !input.value.trim()) {
        this.clearInputError(input);
        return true;
      }
      
      const isValid = input.checkValidity();
      
      if (isValid) {
        this.clearInputError(input);
      } else {
        this.showInputError(input);
      }
      
      return isValid;
    } catch (error) {
      ErrorHandler.error(`Error validating input: ${error.message}`);
      console.error(error);
      return false;
    }
  }
  
  updateStepValidity(step) {
    try {
      if (step.isCard || step.inputs.length === 0) {
        step.setValidity(true);
        return;
      }
      
      const requiredInputs = step.getRequiredInputs();
      
      if (requiredInputs.length === 0) {
        step.setValidity(true);
        return;
      }
      
      const isValid = requiredInputs.every(input => input.checkValidity());
      
      step.setValidity(isValid);
    } catch (error) {
      ErrorHandler.error(`Error updating step validity: ${error.message}`);
      console.error(error);
    }
  }
  
  updateButtonState() {
    try {
      const currentStep = this.form.steps[this.form.currentStepIndex];
      
      this.form.nextButtons.forEach(button => {
        if (this.form.currentStepIndex >= this.form.steps.length - 1) {
          DOMUtils.addClass(button, 'disabled');
          button.disabled = true;
        } else if (!currentStep.isValid) {
          DOMUtils.addClass(button, 'disabled');
          button.disabled = true;
        } else {
          DOMUtils.removeClass(button, 'disabled');
          button.disabled = false;
        }
      });
      
      if (this.form.submitButton) {
        if (this.form.currentStepIndex === this.form.steps.length - 1 && currentStep.isValid) {
          DOMUtils.removeClass(this.form.submitButton, 'disabled');
          this.form.submitButton.disabled = false;
        } else {
          DOMUtils.addClass(this.form.submitButton, 'disabled');
          this.form.submitButton.disabled = true;
        }
      }
    } catch (error) {
      ErrorHandler.error(`Error updating button state: ${error.message}`);
      console.error(error);
    }
  }
  
  showInputError(input) {
    try {
      DOMUtils.addClass(input, 'error');
      
      const wrapper = input.closest('.form-input-wrapper');
      if (wrapper) {
        DOMUtils.addClass(wrapper, 'error');
      }
      
      const errorElement = input.parentElement.querySelector('.error-message');
      if (errorElement) {
        errorElement.textContent = input.validationMessage || 'Invalid input';
        DOMUtils.show(errorElement);
      }
      
      this.eventEmitter.emit('validation:error', { 
        input: input, 
        message: input.validationMessage || 'Invalid input' 
      });
    } catch (error) {
      ErrorHandler.error(`Error showing input error: ${error.message}`);
      console.error(error);
    }
  }
  
  clearInputError(input) {
    try {
      DOMUtils.removeClass(input, 'error');
      
      const wrapper = input.closest('.form-input-wrapper');
      if (wrapper) {
        DOMUtils.removeClass(wrapper, 'error');
      }
      
      const errorElement = input.parentElement.querySelector('.error-message');
      if (errorElement) {
        errorElement.textContent = '';
        DOMUtils.hide(errorElement);
      }
      
      this.eventEmitter.emit('validation:clear', { input: input });
    } catch (error) {
      ErrorHandler.error(`Error clearing input error: ${error.message}`);
      console.error(error);
    }
  }
}

/**
 * PhoneFormatter - Phone number formatting for SimpleFormly
 */
class PhoneFormatter {
  constructor(input, format) {
    this.input = input;
    this.format = format || 'xxx-xxx-xxxx';
    this.initialized = false;
  }
  
  init() {
    try {
      if (this.initialized) {
        ErrorHandler.warn('Phone formatter already initialized');
        return;
      }
      
      this.setupEventListeners();
      
      if (this.input.value) {
        this.formatInput();
      }
      
      this.initialized = true;
      ErrorHandler.log('Phone formatter initialized successfully', 'info');
    } catch (error) {
      ErrorHandler.error(`Error initializing phone formatter: ${error.message}`);
      console.error(error);
    }
  }
  
  setupEventListeners() {
    try {
      this.input.addEventListener('input', () => {
        this.formatInput();
      });
      
      this.input.addEventListener('blur', () => {
        this.formatInput();
      });
      
      ErrorHandler.log('Phone formatter event listeners setup successfully', 'info');
    } catch (error) {
      ErrorHandler.error(`Error setting up phone formatter 
(Content truncated due to size limit. Use line ranges to read in chunks)
